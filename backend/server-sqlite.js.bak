import express from 'express';
import cors from 'cors';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import Database from 'better-sqlite3';
import dotenv from 'dotenv';
import { randomBytes } from 'crypto';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;
const JWT_SECRET = process.env.JWT_SECRET;
const db = new Database(process.env.DATABASE_PATH || './database.db');

db.pragma('foreign_keys = ON');

// Middleware
app.use(cors());
app.use(express.json());

// Generate UUID
const generateId = () => randomBytes(16).toString('hex');

// Auth middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid or expired token' });
    }
    req.user = user;
    next();
  });
};

// ==================== AUTH ROUTES ====================

// Login
app.post('/api/auth/login', (req, res) => {
  try {
    const { email, password } = req.body;

    const user = db.prepare('SELECT * FROM users WHERE email = ? AND is_active = 1').get(email);
    
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const passwordValid = bcrypt.compareSync(password, user.password_hash);
    if (!passwordValid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const token = jwt.sign(
      { id: user.id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    // Remove password hash from response
    delete user.password_hash;

    res.json({ user, token });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

// Get current user
app.get('/api/auth/me', authenticateToken, (req, res) => {
  try {
    const user = db.prepare('SELECT id, auth_user_id, email, full_name, role, department_id, profile_image_url, is_active FROM users WHERE id = ?').get(req.user.id);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json(user);
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ error: 'Failed to get user' });
  }
});

// ==================== DEPARTMENTS ROUTES ====================

app.get('/api/departments', authenticateToken, (req, res) => {
  try {
    const departments = db.prepare('SELECT * FROM departments WHERE is_active = 1 ORDER BY name').all();
    res.json(departments);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== CLASSROOMS ROUTES ====================

app.get('/api/classrooms', authenticateToken, (req, res) => {
  try {
    const classrooms = db.prepare(`
      SELECT c.*, d.name as department_name 
      FROM classrooms c 
      LEFT JOIN departments d ON c.department_id = d.id 
      ORDER BY c.name
    `).all();
    
    // Format for frontend compatibility
    const formatted = classrooms.map(c => ({
      ...c,
      departments: c.department_name ? { name: c.department_name } : null
    }));
    
    res.json(formatted);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/classrooms', authenticateToken, (req, res) => {
  try {
    const { name, location, capacity, department_id, floor, block, is_active } = req.body;
    const id = generateId();
    
    const stmt = db.prepare(`
      INSERT INTO classrooms (id, name, location, capacity, department_id, floor, block, is_active)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(id, name, location, capacity, department_id, floor, block, is_active ? 1 : 0);
    
    const classroom = db.prepare('SELECT * FROM classrooms WHERE id = ?').get(id);
    res.json(classroom);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.patch('/api/classrooms/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    const { name, location, capacity, department_id, floor, block, is_active } = req.body;
    
    const stmt = db.prepare(`
      UPDATE classrooms 
      SET name = ?, location = ?, capacity = ?, department_id = ?, floor = ?, block = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `);
    
    stmt.run(name, location, capacity, department_id, floor, block, is_active ? 1 : 0, id);
    
    const classroom = db.prepare('SELECT * FROM classrooms WHERE id = ?').get(id);
    res.json(classroom);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/classrooms/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    db.prepare('DELETE FROM classrooms WHERE id = ?').run(id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== RFID DEVICES ROUTES ====================

app.get('/api/rfid-devices', authenticateToken, (req, res) => {
  try {
    const devices = db.prepare(`
      SELECT r.*, c.name as classroom_name 
      FROM rfid_devices r 
      LEFT JOIN classrooms c ON r.classroom_id = c.id 
      ORDER BY r.created_at DESC
    `).all();
    
    const formatted = devices.map(d => ({
      ...d,
      is_online: Boolean(d.is_online),
      classrooms: d.classroom_name ? { name: d.classroom_name } : null
    }));
    
    res.json(formatted);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/rfid-devices', authenticateToken, (req, res) => {
  try {
    const { device_name, device_type, mac_address, ip_address, mqtt_topic, secret_key, firmware_version, classroom_id, is_online } = req.body;
    const id = generateId();
    
    const stmt = db.prepare(`
      INSERT INTO rfid_devices (id, device_name, device_type, mac_address, ip_address, mqtt_topic, secret_key, firmware_version, classroom_id, is_online)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(id, device_name, device_type, mac_address, ip_address, mqtt_topic, secret_key, firmware_version, classroom_id, is_online ? 1 : 0);
    
    const device = db.prepare('SELECT * FROM rfid_devices WHERE id = ?').get(id);
    res.json(device);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.patch('/api/rfid-devices/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    const { device_name, device_type, mac_address, ip_address, mqtt_topic, secret_key, firmware_version, classroom_id, is_online } = req.body;
    
    const stmt = db.prepare(`
      UPDATE rfid_devices 
      SET device_name = ?, device_type = ?, mac_address = ?, ip_address = ?, mqtt_topic = ?, secret_key = ?, firmware_version = ?, classroom_id = ?, is_online = ?
      WHERE id = ?
    `);
    
    stmt.run(device_name, device_type, mac_address, ip_address, mqtt_topic, secret_key, firmware_version, classroom_id, is_online ? 1 : 0, id);
    
    const device = db.prepare('SELECT * FROM rfid_devices WHERE id = ?').get(id);
    res.json(device);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/rfid-devices/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    db.prepare('DELETE FROM rfid_devices WHERE id = ?').run(id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== CAMERAS ROUTES ====================

app.get('/api/cameras', authenticateToken, (req, res) => {
  try {
    const cameras = db.prepare(`
      SELECT c.*, cl.name as classroom_name 
      FROM cameras c 
      LEFT JOIN classrooms cl ON c.classroom_id = cl.id 
      ORDER BY c.created_at DESC
    `).all();
    
    const formatted = cameras.map(c => ({
      ...c,
      is_online: Boolean(c.is_online),
      classrooms: c.classroom_name ? { name: c.classroom_name } : null
    }));
    
    res.json(formatted);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/cameras', authenticateToken, (req, res) => {
  try {
    const { camera_name, camera_type, stream_url, resolution, fps, trigger_mode, classroom_id, is_online } = req.body;
    const id = generateId();
    
    const stmt = db.prepare(`
      INSERT INTO cameras (id, camera_name, camera_type, stream_url, resolution, fps, trigger_mode, classroom_id, is_online)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(id, camera_name, camera_type, stream_url, resolution, fps, trigger_mode, classroom_id, is_online ? 1 : 0);
    
    const camera = db.prepare('SELECT * FROM cameras WHERE id = ?').get(id);
    res.json(camera);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.patch('/api/cameras/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    const { camera_name, camera_type, stream_url, resolution, fps, trigger_mode, classroom_id, is_online } = req.body;
    
    const stmt = db.prepare(`
      UPDATE cameras 
      SET camera_name = ?, camera_type = ?, stream_url = ?, resolution = ?, fps = ?, trigger_mode = ?, classroom_id = ?, is_online = ?
      WHERE id = ?
    `);
    
    stmt.run(camera_name, camera_type, stream_url, resolution, fps, trigger_mode, classroom_id, is_online ? 1 : 0, id);
    
    const camera = db.prepare('SELECT * FROM cameras WHERE id = ?').get(id);
    res.json(camera);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/cameras/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    db.prepare('DELETE FROM cameras WHERE id = ?').run(id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== USERS/STUDENTS ROUTES ====================

app.get('/api/users', authenticateToken, (req, res) => {
  try {
    const { role } = req.query;
    let query = `
      SELECT u.id, u.email, u.full_name, u.role, u.department_id, u.rfid_card_id, u.is_active, u.created_at, d.name as department_name
      FROM users u 
      LEFT JOIN departments d ON u.department_id = d.id
    `;
    
    if (role) {
      query += ` WHERE u.role = ? ORDER BY u.full_name`;
      const users = db.prepare(query).all(role);
      const formatted = users.map(u => ({
        ...u,
        departments: u.department_name ? { name: u.department_name } : null
      }));
      res.json(formatted);
    } else {
      query += ` ORDER BY u.full_name`;
      const users = db.prepare(query).all();
      const formatted = users.map(u => ({
        ...u,
        departments: u.department_name ? { name: u.department_name } : null
      }));
      res.json(formatted);
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/users', authenticateToken, (req, res) => {
  try {
    const { full_name, email, role, department_id, rfid_card_id, is_active } = req.body;
    const id = generateId();
    const auth_user_id = generateId();
    const defaultPassword = 'Password@123';
    const password_hash = bcrypt.hashSync(defaultPassword, 10);
    
    const stmt = db.prepare(`
      INSERT INTO users (id, auth_user_id, email, password_hash, full_name, role, department_id, rfid_card_id, is_active)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(id, auth_user_id, email, password_hash, full_name, role, department_id, rfid_card_id, is_active ? 1 : 0);
    
    const user = db.prepare('SELECT id, email, full_name, role, department_id, rfid_card_id, is_active FROM users WHERE id = ?').get(id);
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.patch('/api/users/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    const { full_name, email, role, department_id, rfid_card_id, is_active } = req.body;
    
    const stmt = db.prepare(`
      UPDATE users 
      SET full_name = ?, email = ?, role = ?, department_id = ?, rfid_card_id = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `);
    
    stmt.run(full_name, email, role, department_id, rfid_card_id, is_active ? 1 : 0, id);
    
    const user = db.prepare('SELECT id, email, full_name, role, department_id, rfid_card_id, is_active FROM users WHERE id = ?').get(id);
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/users/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    db.prepare('DELETE FROM users WHERE id = ?').run(id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== TIMETABLE ROUTES ====================

app.get('/api/timetable', authenticateToken, (req, res) => {
  try {
    const timetable = db.prepare(`
      SELECT t.*, c.name as classroom_name, u.full_name as teacher_name
      FROM timetable t 
      LEFT JOIN classrooms c ON t.classroom_id = c.id 
      LEFT JOIN users u ON t.teacher_id = u.id
      WHERE t.is_active = 1
      ORDER BY t.day_of_week, t.start_time
    `).all();
    
    const formatted = timetable.map(t => ({
      ...t,
      classrooms: t.classroom_name ? { name: t.classroom_name } : null,
      users: t.teacher_name ? { full_name: t.teacher_name } : null
    }));
    
    res.json(formatted);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/timetable', authenticateToken, (req, res) => {
  try {
    const { classroom_id, teacher_id, subject_name, section, day_of_week, start_time, end_time, is_active } = req.body;
    const id = generateId();
    
    const stmt = db.prepare(`
      INSERT INTO timetable (id, classroom_id, teacher_id, subject_name, section, day_of_week, start_time, end_time, is_active)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(id, classroom_id, teacher_id, subject_name, section, day_of_week, start_time, end_time, is_active ? 1 : 0);
    
    const entry = db.prepare('SELECT * FROM timetable WHERE id = ?').get(id);
    res.json(entry);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.patch('/api/timetable/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    const { classroom_id, teacher_id, subject_name, section, day_of_week, start_time, end_time, is_active } = req.body;
    
    const stmt = db.prepare(`
      UPDATE timetable 
      SET classroom_id = ?, teacher_id = ?, subject_name = ?, section = ?, day_of_week = ?, start_time = ?, end_time = ?, is_active = ?
      WHERE id = ?
    `);
    
    stmt.run(classroom_id, teacher_id, subject_name, section, day_of_week, start_time, end_time, is_active ? 1 : 0, id);
    
    const entry = db.prepare('SELECT * FROM timetable WHERE id = ?').get(id);
    res.json(entry);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/timetable/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    db.prepare('DELETE FROM timetable WHERE id = ?').run(id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== AUDIT LOGS ROUTES ====================

app.get('/api/audit-logs', authenticateToken, (req, res) => {
  try {
    const logs = db.prepare(`
      SELECT a.*, u.full_name, u.email
      FROM audit_logs a 
      LEFT JOIN users u ON a.user_id = u.id 
      ORDER BY a.created_at DESC 
      LIMIT 100
    `).all();
    
    const formatted = logs.map(l => ({
      ...l,
      users: l.full_name ? { full_name: l.full_name, email: l.email } : null
    }));
    
    res.json(formatted);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/audit-logs', authenticateToken, (req, res) => {
  try {
    const { action_type, entity_type, entity_id, old_values, new_values, ip_address } = req.body;
    const id = generateId();
    
    const stmt = db.prepare(`
      INSERT INTO audit_logs (id, user_id, action_type, entity_type, entity_id, old_values, new_values, ip_address)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(id, req.user.id, action_type, entity_type, entity_id, JSON.stringify(old_values), JSON.stringify(new_values), ip_address);
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== DEVICE HEALTH LOGS ROUTES ====================

app.post('/api/device-health-logs', authenticateToken, (req, res) => {
  try {
    const { device_id, status, signal_strength, response_time_ms } = req.body;
    const id = generateId();
    
    const stmt = db.prepare(`
      INSERT INTO device_health_logs (id, device_id, status, signal_strength, response_time_ms)
      VALUES (?, ?, ?, ?, ?)
    `);
    
    stmt.run(id, device_id, status, signal_strength, response_time_ms);
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', message: 'Server is running' });
});

// Start server
app.listen(PORT, () => {
  console.log(`\nðŸš€ Backend server running on http://localhost:${PORT}`);
  console.log(`ðŸ“Š Database: ${process.env.DATABASE_PATH || './database.db'}`);
  console.log(`\nâœ… Ready to accept requests!`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  db.close();
  process.exit(0);
});
